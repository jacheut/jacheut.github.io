<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JVM内存结构</title>
    <url>/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>JVM 整体由 4 部分组成：</p>
<blockquote>
<p>加载：类加载器 ClassLoader<br>执行：执行引擎<br>内存：运行时数据区，Runtime Date Area<br>内存回收：垃圾回收</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/public/resource/3c3ff9fb6ef41558966833fe2047f1d2/xmlnote/A6931B8E8C564071B2D085E64E1C0D21/28119" alt="alt"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从复制原理</title>
    <url>/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>mysql主从复制需要三个线程，master（binlog dump thread）、slave（I/O thread 、SQL thread）。</strong></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://user-gold-cdn.xitu.io/2019/4/2/169db46b2582abe2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="alt"></p>
<h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><blockquote>
<p>（1）<strong>binlog dump线程</strong>：当主库中有数据更新时，那么主库就会根据按照设置的binlog格式，将此次更新的事件类型写入到主库的binlog文件中，此时主库会创建log dump线程通知slave有数据更新。</p>
</blockquote>
<h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><blockquote>
<p>（2）<strong>I/O线程</strong>：该线程会连接到master，向log dump线程请求一份指定binlog文件位置的副本，并将请求回来的binlog存到本地的relay log中，relay log和binlog日志一样也是记录了数据更新的事件，它也是按照递增后缀名的方式，产生多个relay log（ host_name-relay-bin.000001）文件，slave会使用一个index文件（ host_name-relay-bin.index）来追踪当前正在使用的relay log文件。</p>
</blockquote>
<blockquote>
<p>（3）<strong>SQL线程</strong>：该线程检测到relay log有更新后，会读取并在本地做redo操作，将发生在主库的事件在本地重新执行一遍，来保证主从数据同步。此外，如果一个relay log文件中的全部事件都执行完毕，那么SQL线程会自动将该relay log 文件删除掉。</p>
</blockquote>
<h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p><code>如何解决MySQL主库宕机导致的数据丢失情况？</code></p>
<p>使用半同步复制。在主库commit之前，需要先将binlog同步到从库，主库可以设置同步binlog的过期时间，在binlog复制到从库之后，从库后续会自行重放中继日志。不过这样也增加了客户端的延迟。另外这个需要安装下MySQL的插件。</p>
<p><img src="https://note.youdao.com/yws/public/resource/c9fd2f2bbbcdfdd5b8c1ba3a4f857cda/xmlnote/38525674C8A541A68A3A321D08531D57/28242" alt="alt"></p>
<p>MySQL的半同步插件为：semisync_xx.so</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL规范</title>
    <url>/MySQL%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h1><ul>
<li><p>表存储引擎必须使用InnoDB</p>
</li>
<li><p>表字符集默认使用utf8，必要时候使用utf8mb4</p>
<blockquote>
<p>解读：<br>（1）通用，无乱码风险，汉字3字节，英文1字节<br>（2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它</p>
</blockquote>
</li>
<li><p>禁止使用存储过程，视图，触发器，Event</p>
<blockquote>
<p>解读：<br>（1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层<br>（2）调试，排错，迁移都比较困难，扩展性较差</p>
</blockquote>
</li>
<li><p>禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径</p>
</li>
<li><p>禁止在线上环境做数据库压力测试</p>
</li>
<li><p>测试，开发，线上数据库环境必须隔离</p>
</li>
</ul>
<h1 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h1><ul>
<li><p>库名，表名，列名必须用小写，采用下划线分隔</p>
</li>
<li><p>库名，表名，列名必须见名知义，长度不要超过32字符</p>
</li>
<li><p>库备份必须以bak为前缀，以日期为后缀</p>
</li>
<li><p>从库必须以-s为后缀</p>
</li>
<li><p>备库必须以-ss为后缀</p>
</li>
</ul>
<h1 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h1><ul>
<li><p>单实例表个数必须控制在2000个以内</p>
</li>
<li><p>单表分表个数必须控制在1024个以内</p>
</li>
<li><p>表必须有主键，推荐使用UNSIGNED整数为主键</p>
<blockquote>
<p>潜在坑：删除无主键的表，如果是row模式的主从架构，从库会挂住</p>
</blockquote>
</li>
<li><p>禁止使用外键，如果要保证完整性，应由应用程式实现</p>
<blockquote>
<p>解读：外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈</p>
</blockquote>
</li>
<li><p>建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据</p>
</li>
</ul>
<h1 id="四、列设计规范"><a href="#四、列设计规范" class="headerlink" title="四、列设计规范"></a>四、列设计规范</h1><ul>
<li><p>根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节</p>
</li>
<li><p>根据业务区分使用char/varchar</p>
<blockquote>
<p>解读：<br>（1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高<br>（2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间</p>
</blockquote>
</li>
<li><p>根据业务区分使用datetime/timestamp</p>
<blockquote>
<p>解读：前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime</p>
</blockquote>
</li>
<li><p>必须把字段定义为NOT NULL并设默认值</p>
<blockquote>
<p>解读：<br>（1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化<br>（2）NULL需要更多的存储空间<br>（3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑</p>
</blockquote>
</li>
<li><p>使用INT UNSIGNED存储IPv4，不要用char(15)</p>
</li>
<li><p>使用varchar(20)存储手机号，不要使用整数</p>
<blockquote>
<p>解读：<br>（1）牵扯到国家代号，可能出现+/-/()等字符，例如+86<br>（2）手机号不会用来做数学运算<br>（3）varchar可以模糊查询，例如like ‘138%’</p>
</blockquote>
</li>
<li><p>使用TINYINT来代替ENUM</p>
<blockquote>
<p>解读：ENUM增加新值要进行DDL操作</p>
</blockquote>
</li>
</ul>
<h1 id="五、索引规范"><a href="#五、索引规范" class="headerlink" title="五、索引规范"></a>五、索引规范</h1><ul>
<li><p>唯一索引使用uniq_[字段名]来命名</p>
</li>
<li><p>非唯一索引使用idx_[字段名]来命名</p>
</li>
<li><p>单张表索引数量建议控制在5个以内</p>
<blockquote>
<p>解读：<br>（1）互联网高并发业务，太多索引会影响写性能<br>（2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引<br>（3）异常复杂的查询需求，可以选择ES等更为适合的方式存储</p>
</blockquote>
</li>
<li><p>组合索引字段数不建议超过5个</p>
<blockquote>
<p>解读：如果5个字段还不能极大缩小row范围，八成是设计有问题</p>
</blockquote>
</li>
<li><p>不建议在频繁更新的字段上建立索引</p>
</li>
<li><p>非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引</p>
<blockquote>
<p>解读：踩过因为JOIN字段类型不一致，而导致全表扫描的坑么？</p>
</blockquote>
</li>
<li><p>理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)</p>
</li>
</ul>
<h1 id="六、SQL规范"><a href="#六、SQL规范" class="headerlink" title="六、SQL规范"></a>六、SQL规范</h1><ul>
<li><p>禁止使用select *，只获取必要字段</p>
<blockquote>
<p>解读：<br>（1）select *会增加cpu/io/内存/带宽的消耗<br>（2）指定字段能有效利用索引覆盖<br>（3）指定字段查询，在表结构变更时，能保证对应用程序无影响</p>
</blockquote>
</li>
<li><p>insert必须指定字段，禁止使用insert into T values()</p>
<blockquote>
<p>解读：指定字段插入，在表结构变更时，能保证对应用程序无影响</p>
</blockquote>
</li>
<li><p>隐式类型转换会使索引失效，导致全表扫描</p>
</li>
<li><p>禁止在where条件列使用函数或者表达式</p>
<blockquote>
<p>解读：导致不能命中索引，全表扫描</p>
</blockquote>
</li>
<li><p>禁止负向查询以及%开头的模糊查询</p>
<blockquote>
<p>解读：导致不能命中索引，全表扫描</p>
</blockquote>
</li>
<li><p>禁止大表JOIN和子查询</p>
</li>
<li><p>同一个字段上的OR必须改写问IN，IN的值必须少于50个</p>
</li>
<li><p>应用程序必须捕获SQL异常，方便定位线上问题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法之堆排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。</p>
<p>由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合，过程如下：</p>
<p><img src="https://note.youdao.com/yws/public/resource/5370469c4370772e8d8231c58a3be5da/xmlnote/FF36300C3F174AF39069AC452A2BAD15/28612" alt="alt"></p>
<p><img src="https://note.youdao.com/yws/public/resource/5370469c4370772e8d8231c58a3be5da/xmlnote/0167539890B64F42877E06840CF5F9BB/28614" alt="alt"></p>
<p>如上图所示，在删除值为10的堆顶节点后，经过调整，值为9的新节点就会被替换上来。</p>
<p>删除节点9，节点8成为新堆顶：</p>
<p><img src="https://note.youdao.com/yws/public/resource/5370469c4370772e8d8231c58a3be5da/xmlnote/1BC0CED453B8489280141227BCCEFA3C/13454" alt="alt"></p>
<p>删除节点8，节点7成为新堆顶：<br><img src="https://note.youdao.com/yws/public/resource/5370469c4370772e8d8231c58a3be5da/xmlnote/ADD225D5C2E149B0A1132B54C5A1A2A5/13456" alt="alt"></p>
<p>删除节点7，节点6成为新堆顶：</p>
<p><img src="https://note.youdao.com/yws/public/resource/5370469c4370772e8d8231c58a3be5da/xmlnote/3D8BE46A4AC84FE695076BE26C6227BE/13453" alt="alt"></p>
<p>依次类推，我们原本的最大堆已经变成了一个从小到大的有序集合。之前说过二叉堆实际存储在数组当中，数组中的元素排列如下：</p>
<p><img src="https://note.youdao.com/yws/public/resource/5370469c4370772e8d8231c58a3be5da/xmlnote/1FB68ED60EBC44E18407F34F1545937B/13455" alt="alt"></p>
<p>由此，我们可以归纳出堆排序算法的步骤：</p>
<ul>
<li>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小<br>排序，则构建成最小堆。</li>
<li>循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 下沉调整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> array  待调整的堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 要下沉的父节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆的有效大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// temp保存父节点值，用于最后的赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (childIndex &lt; length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                childIndex++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (temp &gt;= array[childIndex]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//无需真正交换，单向赋值即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[parentIndex] = array[childIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parentIndex = childIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        array[parentIndex] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 堆排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 待调整的堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 1.把无序数组构建成二叉堆。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            downAdjust(array, i, array.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Arrays.toString(array));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 2.循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 最后一个元素和第一元素进行交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> temp = array[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[i] = array[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[<span class="number">0</span>] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 下沉调整最大堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            downAdjust(array, <span class="number">0</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        heapSort(array);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Arrays.toString(array));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="空间复杂度O（1）"><a href="#空间复杂度O（1）" class="headerlink" title="空间复杂度O（1）"></a>空间复杂度O（1）</h2><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><blockquote>
<p>二叉堆的节点下沉调整（downAdjust 方法）是堆排序算法的基础，这个调节操作本身的时间复杂度是多少呢？</p>
</blockquote>
<p>假设二叉堆总共有n个元素，那么下沉调整的最坏时间复杂度就等同于二叉堆的高度，也就是O（logn）。</p>
<p>我们再来回顾一下堆排序算法的步骤：</p>
<ul>
<li>把无序数组构建成二叉堆。</li>
<li>循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</li>
</ul>
<p>第一步，把无序数组构建成二叉堆，需要进行n/2次循环。每次循环调用一次 downAdjust 方法，所以第一步的计算规模是  n/2 * logn，时间复杂度O（nlogn）。</p>
<p>第二步，需要进行n-1次循环。每次循环调用一次 downAdjust 方法，所以第二步的计算规模是 （n-1） * logn ，时间复杂度 O（nlogn）。</p>
<p>两个步骤是并列关系，所以整体的时间复杂度同样是 O（nlogn）。</p>
<p><code>堆排序是不稳定排序</code></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是二叉堆？</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    <content><![CDATA[<p>二叉堆本质上是一种完全二叉树，它分为两个类型：</p>
<ul>
<li>最大堆：最大堆任何一个父节点的值，都大于等于它左右孩子节点的值。</li>
<li>最小堆：最小堆任何一个父节点的值，都小于等于它左右孩子节点的值。</li>
</ul>
<p>二叉堆的根节点叫做堆顶。</p>
<p>最大堆和最小堆的特点，决定了在最大堆的堆顶是整个堆中的最大元素；最小堆的堆顶是整个堆中的最小元素。</p>
<h1 id="堆的自我调整"><a href="#堆的自我调整" class="headerlink" title="堆的自我调整"></a>堆的自我调整</h1><p>对于二叉堆，如下有几种操作：</p>
<p>插入节点<br>删除节点<br>构建二叉堆</p>
<p>这几种操作都是基于堆的自我调整。</p>
<p>下面让我们以最小堆为例，看一看二叉堆是如何进行自我调整的。</p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>二叉堆的节点插入，插入位置是完全二叉树的最后一个位置。比如我们插入一个新节点，值是 0。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/84AE54B6B30D48EF86427D9F4D47B8D7/13426" alt="alt"></p>
<p>这时候，我们让节点0的它的父节点5做比较，如果0小于5，则让新节点“上浮”，和父节点交换位置。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/5101CF2641B54C93A3F49DC31AE4E52D/13439" alt="alt"></p>
<p>继续用节点0和父节点3做比较，如果0小于3，则让新节点继续“上浮”。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/3F84F72235DC4CB29D433BBACACF113C/13428" alt="alt"></p>
<p>继续比较，最终让新节点0上浮到了堆顶位置。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/928F09279CFE4235BB9902BB509F6BE3/13427" alt="alt"></p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>二叉堆的节点删除过程和插入过程正好相反，所删除的是处于堆顶的节点。比如我们删除最小堆的堆顶节点1。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/A92E258C406846D1BF5B22E6CA2F59CA/13432" alt="alt"></p>
<p>这时候，为了维持完全二叉树的结构，我们把堆的最后一个节点10补到原本堆顶的位置。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/1AA03D43DE0C425781B0527BAB5443FC/13430" alt="alt"></p>
<p>接下来我们让移动到堆顶的节点10和它的左右孩子进行比较，如果左右孩子中最小的一个（显然是节点2）比节点10小，那么让节点10“下沉”。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/CE53D64C4BC24624A2DB662314D6C117/13429" alt="alt"></p>
<p>继续让节点10和它的左右孩子做比较，左右孩子中最小的是节点7，由于10大于7，让节点10继续“下沉”。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/D124AEEB4FC44EF7BB91AD916F97BF70/13431" alt="alt"></p>
<p>这样一来，二叉堆重新得到了调整。</p>
<h2 id="构建二叉堆"><a href="#构建二叉堆" class="headerlink" title="构建二叉堆"></a>构建二叉堆</h2><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。</p>
<p>我们举一个无序完全二叉树的例子：</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/60E197D212E3403EBD3E82928385EA7D/13433" alt="alt"></p>
<p>首先，我们从最后一个非叶子节点开始，也就是从节点10开始。如果节点10大于它左右孩子中最小的一个，则节点10下沉。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/FC0FAC5C07824E1286FEE14265ECB35A/13436" alt="alt"></p>
<p>接下来轮到节点3，如果节点3大于它左右孩子中最小的一个，则节点3下沉。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/0D9B25283274411591EC0AF71A2D5E25/13437" alt="alt"></p>
<p>接下来轮到节点1，如果节点1大于它左右孩子中最小的一个，则节点1下沉。事实上节点1小于它的左右孩子，所以不用改变。</p>
<p>接下来轮到节点7，如果节点7大于它左右孩子中最小的一个，则节点7下沉。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/33E7D360D6D84AD88D9E388875C17A7E/13438" alt="alt"></p>
<p>节点7继续比较，继续下沉。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/55F6C3F67ECD466684E080E2AEF43685/13435" alt="alt"></p>
<p>这样一来，一颗无序的完全二叉树就构建成了一个最小堆。</p>
<h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>堆的插入和删除操作时间复杂度是O(logn)。构建堆的时间复杂度是O(n)。</p>
<p>构建堆的复杂度推导：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建立堆的顺序是bottom-top的。 </span></pre></td></tr><tr><td class="code"><pre><span class="line">正确的证明方法应当如下：</span></pre></td></tr><tr><td class="code"><pre><span class="line">具有n个元素的平衡二叉树，树高为㏒n，我们设这个变量为h。</span></pre></td></tr><tr><td class="code"><pre><span class="line">最下层非叶节点的元素，只需做一次线性运算便可以确定大根，而这一层具有2^(h-1)个元素，我们假定O(1)&#x3D;1，那么这一层元素所需时间为2^(h-1) × 1。</span></pre></td></tr><tr><td class="code"><pre><span class="line">由于是bottom-top建立堆，因此在调整上层元素的时候，并不需要同下层所有元素做比较，只需要同其中之一分支作比较，而作比较次数则是树的高度减去当前节点的高度。因此，第x层元素的计算量为2^(x-1) × (h-x)。</span></pre></td></tr><tr><td class="code"><pre><span class="line">由以上通项公式可得知，构造树高为h的二叉堆的精确时间复杂度为： </span></pre></td></tr><tr><td class="code"><pre><span class="line">S &#x3D; 2^(h-1) × 1 + 2^(h-2) × 2 + …… +1 × (h-1) ①</span></pre></td></tr><tr><td class="code"><pre><span class="line">通过观察第四步得出的公式可知，该求和公式为等差数列和等比数列的乘积，因此用错位想减发求解，给公式左右两侧同时乘以2，可知： </span></pre></td></tr><tr><td class="code"><pre><span class="line">2S &#x3D; 2^h × 1 + 2^(h-1) × 2+ …… +2 × (h-1) ②</span></pre></td></tr><tr><td class="code"><pre><span class="line">用②减去①可知： S &#x3D;2^h +2^h-1+2^h-2......2^1- h +1&#x3D;2^(h+1)-h+1 ③</span></pre></td></tr><tr><td class="code"><pre><span class="line">将h &#x3D; ㏒n 带入③，得出如下结论：</span></pre></td></tr><tr><td class="code"><pre><span class="line">S &#x3D; 2*n - ㏒n -1 &#x3D; O(n)</span></pre></td></tr></table></figure>
<p>结论：<code>构造二叉堆的时间复杂度为线性得证</code>。</p>
<h1 id="堆的代码实现"><a href="#堆的代码实现" class="headerlink" title="堆的代码实现"></a>堆的代码实现</h1><p>二叉堆虽然是一颗完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组当中。</p>
<p><img src="https://note.youdao.com/yws/public/resource/4ae50a760a9ea313e67f5b5d90a3275c/xmlnote/CF322829B30948DFA41618185575F45A/13434" alt="alt"></p>
<blockquote>
<p>数组中，在没有左右指针的情况下，如何定位到一个父节点的左孩子和右孩子呢？</p>
</blockquote>
<p>像图中那样，我们可以依靠数组下标来计算。</p>
<p>假设父节点的下标是parent，那么它的左孩子下标就是 2<em>parent+1；它的右孩子下标就是  2</em>parent+2 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOperator</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 上浮调整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> array  待调整的堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//最后一个节点 子节点索引位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> childIndex = array.length - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//父节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// temp保存插入的叶子节点值，用于最后的赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> temp = array[childIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[parentIndex]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//无需真正交换，单向赋值即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[childIndex] = array[parentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            childIndex = parentIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parentIndex = (childIndex - <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        array[childIndex] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 下沉调整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> array  待调整的堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentIndex 要下沉的父节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 堆的有效大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// temp保存父节点值，用于最后的赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> temp = array[parentIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> childIndex = parentIndex * <span class="number">2</span> + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (childIndex &lt; length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &lt; array[childIndex]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                childIndex++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果父节点小于任何一个孩子的值，直接跳出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (temp &lt;= array[childIndex]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//无需真正交换，单向赋值即可</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            array[parentIndex] = array[childIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parentIndex = childIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            childIndex = childIndex * <span class="number">2</span> + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        array[parentIndex] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 构建堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 待调整的堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从最后一个非叶子节点开始，依次下沉调整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length/<span class="number">2</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            downAdjust(array, i, array.length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        upAdjust(array);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Arrays.toString(array));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        buildHeap(array);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Arrays.toString(array));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<p>二叉堆是实现堆排序和优先级队列的基础。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>十大经典排序算法之快速排序</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a>快排思想</h1><p>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，但最佳的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；</p>
<p>2.将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；</p>
<p>3.对左右两个分区重复以上步骤直到所有元素都是有序的。</p>
<blockquote>
<p>每次把数列分成两部分，究竟有什么好处呢？</p>
</blockquote>
<p>假如给出一个8个元素的数列，一般情况下，使用冒泡排序需要比较7轮，每一轮把1个元素移动到数列的一端，时间复杂度是O(n2)。</p>
<p>而快排每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是O(n)。</p>
<blockquote>
<p>这样的遍历一共需要多少轮呢？</p>
</blockquote>
<p>假如元素个数是n，那么平均情况下需要logn轮，因此快速排序算法总体的平均时间复杂度是O(nlogn)。但最坏情况下的时间复杂度是O(n2)。</p>
<p>快排的空间复杂度是O(lgn)，因为快排的实现是递归调用的， 而且每次函数调用中只使用了常数的空间，因此空间复杂度等于递归深度O(lgn)。</p>
<h1 id="基准元素的选择"><a href="#基准元素的选择" class="headerlink" title="基准元素的选择"></a>基准元素的选择</h1><p>随机选择一个元素作为基准元素，并且让基准元素和数列首元素交换位置。</p>
<h1 id="元素的交换"><a href="#元素的交换" class="headerlink" title="元素的交换"></a>元素的交换</h1><h2 id="双边循环法"><a href="#双边循环法" class="headerlink" title="双边循环法"></a>双边循环法</h2><p>给出原始数列如下，要求对其从小到大进行排序。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/218262591CF44024A38008ADB5F923A6/22921" alt="alt"></p>
<p>首先，选定基准元素pivot，并且设置两个指针left和right，指向数列的最左和最右两个元素。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/E070FE923A2B4D59A449133DE117B3BB/22924" alt="alt"></p>
<p>接下来进行第1次循环，从right指针开始，让指针所指向的元素和基准元素做比较。<br>如果大于或等于pivot，则指针向左移动；如果小于pivot，则right指针停止移动，切换到left指针。</p>
<p>在当前数列中，1&lt;4，所以right直接停止移动，换到left指针，进行下一步行动。<br>轮到left指针行动，让指针所指向的元素和基准元素做比较。如果小于或等于pivot，<br>则指针向右移动；如果大于pivot，则left指针停止移动。</p>
<p>由于left开始指向的是基准元素，判断肯定相等，所以left右移1位。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/CCABD315C5ED4F14B4117EDA97ABD07F/22926" alt="alt"></p>
<p>由于7&gt;4，left指针在元素7的位置停下。这时，让left和right指针所指向的元素进行交换。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/8313E7651D634B918CF48CAB37EAF80A/22930" alt="alt"></p>
<p>接下来，进入第2次循环，重新切换到right指针，向左移动。right指针先移动到8，8&gt;4，继续左移。由于2&lt;4，停止在2的位置。</p>
<p>按照这个思路，后续步骤如图所示。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/34925DCF54F7416D82B4191C7934F1F1/22934" alt="alt"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 递归结束条件：startIndex大等于endIndex的时候</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 得到基准元素位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 用分治法递归数列的两部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 分治（双边循环法）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr        待交换的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 起始下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex   结束下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 取第一个位置（也可以选择随机位置）的元素作为基准元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> left = startIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> right = endIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//大循环在左右指针重合或者交错时结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//控制right 指针比较并左移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                right--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//控制left指针比较并右移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                left++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//交换left和right 指针所指向的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> p = arr[left];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                arr[left] = arr[right];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                arr[right] = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//pivot 和指针重合点交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[startIndex] = arr[left];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[left] = pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(Arrays.toString(arr));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<h2 id="单边循环法"><a href="#单边循环法" class="headerlink" title="单边循环法"></a>单边循环法</h2><p>给出原始数列如下，要求对其从小到大进行排序。<br><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/115A957941F54E64A41BABAB3A34FC6F/22942" alt="alt"></p>
<p>开始和双边循环法相似，首先选定基准元素pivot。同时，设置一个mark指针指向数列起始位置，这个mark指针代表小于基准元素的区域边界。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/8E95234C60004D4CB77AAFB5247E1157/22945" alt="alt"></p>
<p>接下来，从基准元素的下一个位置开始遍历数组。</p>
<p>如果遍历到的元素大于基准元素，就继续往后遍历。<br>如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1；<br>第二，让最新遍历到的元素和mark指针所在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/69354E43942044A68DED7EA1A3D955F0/22954" alt="alt"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 分治（单边循环法）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr        待交换的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 起始下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex   结束下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 取第一个位置（也可以选择随机位置）的元素作为基准元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mark = startIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex + <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mark++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> p = arr[mark];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                arr[mark] = arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                arr[i] = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[startIndex] = arr[mark];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[mark] = pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h1><p>绝大多数用递归实现的问题，绝大多数可以用栈的方式来代替。</p>
<p>因为我们代码中一层一层的方法调用，本身就是一个函数栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。</p>
<p>所以，我们可以把原本的递归实现转化成一个栈的实现，在栈当中存储每一次方法调用的参数：</p>
<p><img src="https://note.youdao.com/yws/public/resource/12b772fd82405a0e18d272806aca46e8/xmlnote/8D93B9B5204846EFB51A88B316DFC5CB/22960" alt="alt"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 用一个集合栈来代替递归的函数栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, Integer&gt; rootParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        rootParam.put(<span class="string">"startIndex"</span>, startIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        rootParam.put(<span class="string">"endIndex"</span>, endIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        quickSortStack.push(rootParam);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 循环结束条件：栈为空时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 栈顶元素出栈，得到起止下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Map&lt;String, Integer&gt; param = quickSortStack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 得到基准元素位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">"startIndex"</span>), param.get(<span class="string">"endIndex"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (param.get(<span class="string">"startIndex"</span>) &lt; pivotIndex - <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                leftParam.put(<span class="string">"startIndex"</span>, param.get(<span class="string">"startIndex"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                leftParam.put(<span class="string">"endIndex"</span>, pivotIndex - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                quickSortStack.push(leftParam);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (param.get(<span class="string">"endIndex"</span>) &gt; pivotIndex + <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                rightParam.put(<span class="string">"startIndex"</span>, pivotIndex + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                rightParam.put(<span class="string">"endIndex"</span>, param.get(<span class="string">"endIndex"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                quickSortStack.push(rightParam);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 分治（单边循环法）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr        待交换的数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 起始下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex   结束下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 取第一个位置（也可以选择随机位置）的元素作为基准元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pivot = arr[startIndex];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mark = startIndex;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex + <span class="number">1</span>; i &lt;= endIndex; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mark++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> p = arr[mark];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                arr[mark] = arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                arr[i] = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[startIndex] = arr[mark];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[mark] = pivot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mark;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<p>和刚才的递归实现相比，代码的变动仅仅在quickSort方法当中。该方法中引入了一个存储Map类型元素的栈，用于存储每一次交换时的起始下标和结束下标。</p>
<p>每一次循环，都会让栈顶元素出栈，进行排序，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>895.最大频率栈</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现 <code>FreqStack</code>，模拟类似栈的数据结构的操作的一个类。</p>
<p><code>FreqStack</code> 有两个函数：</p>
<ul>
<li><code>push(int x)</code>，将整数 <code>x</code> 推入栈中。</li>
</ul>
<ul>
<li>pop()，它移除并返回栈中出现最频繁的元素。<ul>
<li>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span></pre></td></tr><tr><td class="code"><pre><span class="line">[&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],</span></pre></td></tr><tr><td class="code"><pre><span class="line">[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：[null,null,null,null,null,null,null,5,7,5,4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">解释：</span></pre></td></tr><tr><td class="code"><pre><span class="line">执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pop() -&gt; 返回 5，因为 5 是出现频率最高的。</span></pre></td></tr><tr><td class="code"><pre><span class="line">栈变成 [5,7,5,7,4]。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pop() -&gt; 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。</span></pre></td></tr><tr><td class="code"><pre><span class="line">栈变成 [5,7,5,4]。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pop() -&gt; 返回 5 。</span></pre></td></tr><tr><td class="code"><pre><span class="line">栈变成 [5,7,4]。</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">pop() -&gt; 返回 4 。</span></pre></td></tr><tr><td class="code"><pre><span class="line">栈变成 [5,7]。</span></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>对 <code>FreqStack.push(int x)</code> 的调用中 <code>0 &lt;= x &lt;= 10^9</code>。</li>
<li>如果栈的元素数目为零，则保证不会调用 <code>FreqStack.pop()</code>。</li>
<li>单个测试样例中，对 <code>FreqStack.push</code> 的总调用次数不会超过 <code>10000</code>。</li>
<li>单个测试样例中，对 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>10000</code>。</li>
<li>所有测试样例中，对 <code>FreqStack.push</code> 和 <code>FreqStack.pop</code> 的总调用次数不会超过 <code>150000</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FreqStack</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * FreqStack obj = new FreqStack();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * obj.push(x);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr></table></figure>



<h1 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h1><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 记录元素x到x出现次数的映射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;Integer, Integer&gt; freq;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 记录频率到具有该频率的元素的映射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Map&lt;Integer, Stack&lt;Integer&gt;&gt; group;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 当前最大频率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxfreq;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FreqStack</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        freq = <span class="keyword">new</span> HashMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        group = <span class="keyword">new</span> HashMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxfreq = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> f = freq.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        freq.put(x, f);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (f &gt; maxfreq)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            maxfreq = f;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        group.computeIfAbsent(f, z -&gt; <span class="keyword">new</span> Stack()).push(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x = group.get(maxfreq).pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        freq.put(x, freq.get(x) - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (group.get(maxfreq).size() == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            maxfreq--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水-每天一道LeetCode</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/leetcode_42_1.png" alt></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span></pre></td></tr><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1] </span></pre></td></tr><tr><td class="code"><pre><span class="line">输出: 6</span></pre></td></tr></table></figure>


<h1 id="方法一：单调栈"><a href="#方法一：单调栈" class="headerlink" title="方法一：单调栈"></a>方法一：单调栈</h1><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/leetcode_42_7.png" alt></p>
<p>说到栈，我们肯定会想到括号匹配了。我们仔细观察蓝色的部分，可以和括号匹配类比下。每次匹配出一对括号（找到对应的一堵墙），就计算这两堵墙中的水。</p>
<p>我们用栈保存每堵墙。</p>
<p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体的原则就是，</p>
<p>当前高度小于等于栈顶高度，入栈，指针后移。</p>
<p>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p>
<p>我们看具体的例子。</p>
<ul>
<li>首先将 height[0] 入栈。然后 current 指向的高度大于栈顶高度，所以把栈顶 height[0] 出栈，然后栈空了，再把 height[1] 入栈。current 后移。</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/leetcode_42_8.png" alt></p>
<ul>
<li>然后 current 指向的高度小于栈顶高度，height [ 2 ] 入栈，current 后移。</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/leetcode_42_9.png" alt></p>
<ul>
<li>然后 current 指向的高度大于栈顶高度，栈顶 height [ 2 ] 出栈。计算 height [ 3 ] 和新的栈顶之间的水。计算完之后继续判断 current 和新的栈顶的关系。</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88/%E6%8E%A5%E9%9B%A8%E6%B0%B4/leetcode_42_10.png" alt></p>
<ul>
<li>current 指向的高度大于栈顶高度，栈顶 height [ 1 ] 出栈，栈空。所以把 height [ 3 ] 入栈。currtent 后移。</li>
</ul>
<p>…</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap6</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (current &lt; height.length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//如果栈不空并且当前指向的高度大于栈顶高度就一直循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; height[current] &gt; height[stack.peek()]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> h = height[stack.peek()]; <span class="comment">//取出要出栈的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            stack.pop(); <span class="comment">//出栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (stack.empty()) &#123; <span class="comment">// 栈空就出去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> distance = current - stack.peek() - <span class="number">1</span>; <span class="comment">//两堵墙之前的距离。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> min = Math.min(height[stack.peek()], height[current]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sum = sum + distance * (min - h);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stack.push(current); <span class="comment">//当前指向的墙入栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        current++; <span class="comment">//指针后移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：虽然 while 循环里套了一个 while 循环，但是考虑到每个元素最多访问两次，入栈一次和出栈一次，所以时间复杂度是 O(n)。</p>
<p>空间复杂度：O(n)。栈的空间。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>994.腐烂的橘子</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/leetcode_994_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：4</span></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[0,2]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：0</span></pre></td></tr><tr><td class="code"><pre><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ol>
<h1 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h1><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。<br>然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点，注意判断结点位于网格边界的特殊情况。<br>由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历到一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> m = grid.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 一开始，我们找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// count 表示新鲜橘子的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 遍历二维数组 找出所有的新鲜橘子和腐烂的橘子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    count++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 腐烂的橘子就放进队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> round = <span class="number">0</span>; <span class="comment">// round 表示腐烂的轮数，或者分钟数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 直到上下左右都触及边界 或者 被感染的橘子已经遍历完</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// BFS 层级 + 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            round++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 拿到当前层级的腐烂橘子数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> row = queue.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 遍历当前层级的队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 踢出队列（拿出一个腐烂的橘子）, 恢复腐烂橘子的坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span>[] orange = queue.poll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> r = orange[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> c = orange[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// ↑ 上邻点 判断是否边界 并且 上方是否是健康的橘子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    grid[r - <span class="number">1</span>][c] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    count--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 把被感染的橘子放进队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r - <span class="number">1</span>, c&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// ↓ 下邻点 同上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (r+<span class="number">1</span> &lt; m &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    grid[r+<span class="number">1</span>][c] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    count--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>, c&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// ← 左邻点 同上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    grid[r][c-<span class="number">1</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    count--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c-<span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// → 右邻点 同上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (c+<span class="number">1</span> &lt; n &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    grid[r][c+<span class="number">1</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    count--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c+<span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 如果此时还有健康的橘子 返回-1，否则返回round</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> round;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>O(nm)</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>200.岛屿数量</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="code"><pre><span class="line">11110</span></pre></td></tr><tr><td class="code"><pre><span class="line">11010</span></pre></td></tr><tr><td class="code"><pre><span class="line">11000</span></pre></td></tr><tr><td class="code"><pre><span class="line">00000</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出: 1</span></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span></pre></td></tr><tr><td class="code"><pre><span class="line">11000</span></pre></td></tr><tr><td class="code"><pre><span class="line">11000</span></pre></td></tr><tr><td class="code"><pre><span class="line">00100</span></pre></td></tr><tr><td class="code"><pre><span class="line">00011</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出: 3</span></pre></td></tr><tr><td class="code"><pre><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span></pre></td></tr></table></figure>


<h1 id="方法一：并查集"><a href="#方法一：并查集" class="headerlink" title="方法一：并查集"></a>方法一：并查集</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Union</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] union;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Union(<span class="keyword">char</span>[][] grid) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> rows = grid.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            union = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 初始化并查集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">int</span> index = i * cols + j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="comment">// 初始化指向自己</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        union[index] = index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        count++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 找到终点 递归查找</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (union[index] != index) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                union[index] = find(union[index]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> union[index];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 合并并查集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> end1 = find(index1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> end2 = find(index2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (end1 != end2) &#123; <span class="comment">// 不是同一终点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                union[end2] = end1; <span class="comment">// 合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                count--; <span class="comment">// 岛屿数 -1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] moveX = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            moveY = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Union union = <span class="keyword">new</span> Union(grid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> rows = grid.length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 将上下左右的 1 合并在一起</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; moveX.length; k++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">int</span> x = i + moveX[k];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">int</span> y = j + moveY[k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (isValid(grid, rows, cols, x, y)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            union.union(i * cols + j, x * cols + y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> union.count;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="string">'1'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span>[][] grid = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'1'</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'0'</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;<span class="string">'1'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="keyword">new</span> Solution().numIslands(grid));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>1135. 最低成本联通所有城市</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/leetcode/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC%E8%81%94%E9%80%9A%E6%89%80%E6%9C%89%E5%9F%8E%E5%B8%82/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>想象一下你是个城市基建规划者，地图上有 N 座城市，它们按以 1 到 N 的次序编号。</p>
<p>给你一些可连接的选项 conections，其中每个选项 conections[i] = [city1, city2, cost] 表示将城市 city1 和城市 city2 连接所要的成本。（连接是双向的，也就是说城市 city1 和城市 city2 相连也同样意味着城市 city2 和城市 city1 相连）。</p>
<p>返回使得每对城市间都存在将它们连接在一起的连通路径（可能长度为 1 的）最小成本。该最小成本应该是所用全部连接代价的综合。如果根据已知条件无法完成该项任务，则请你返回 -1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 3, conections &#x3D; [[1,2,5],[1,3,6],[2,3,1]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：6</span></pre></td></tr><tr><td class="code"><pre><span class="line">解释：</span></pre></td></tr><tr><td class="code"><pre><span class="line">选出任意 2 条边都可以连接所有城市，我们从中选取成本最小的 2 条。</span></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 4, conections &#x3D; [[1,2,3],[3,4,4]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">输出：-1</span></pre></td></tr><tr><td class="code"><pre><span class="line">解释： </span></pre></td></tr><tr><td class="code"><pre><span class="line">即使连通所有的边，也无法连接所有城市。</span></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li><code>1 &lt;= N &lt;= 10000</code></li>
<li><code>1 &lt;= conections.length &lt;= 10000</code></li>
<li><code>1 &lt;= conections[i][0], conections[i][1] &lt;= N</code></li>
<li><code>0 &lt;= conections[i][2] &lt;= 10^5</code></li>
<li><code>conections[i][0] != conections[i][1]</code></li>
</ol>
<h1 id="方法一：kruskal算法"><a href="#方法一：kruskal算法" class="headerlink" title="方法一：kruskal算法"></a>方法一：kruskal算法</h1><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>1）初始阶段，每个点互不相识，各自为一个孤岛。<br>2）以题设给定的“边”为入手，不断的通过整合边所连接两个点，让所有孤岛都连接到一起。<br>3）利用贪心算法，选择cost小的边为起点，遍历所有的边。<br>4）遍历的过程中，如果发现当前边所在的两个点在两个孤岛上，则将他们合并。这一步采用的并查集方法（即为不同的集合寻找father，father相同的节点，为同一个集合）。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 集合关系表，用一个数组来描述N个节点的集合关系；等同于树的数组表示方法。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] p;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> row;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> col;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] connections)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pointNum = <span class="number">0</span>; <span class="comment">// 联通的边数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        PriorityQueue&lt;Node&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;((Node o1, Node o2) -&gt; (o1.val - o2.val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] connection : connections) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node node = <span class="keyword">new</span> Node();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node.row = connection[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node.col = connection[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            node.val = connection[<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            heap.add(node);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node conn = heap.poll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> px = find(conn.row), py = find(conn.col);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(px != py) &#123; <span class="comment">//如果该边所在的两个节点不在同一个集合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p[px] = py; <span class="comment">//合并集合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans += conn.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pointNum++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//对于无向图的话，至少需要n-1条边可以使得图是联通的；</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//如果对于有向图的话，至少需要n条边才可以使得图是联通的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(pointNum == N - <span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * 不断向上找，直到找到下标和元素相同的点。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (x != p[x]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x = p[x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[][] connections = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="keyword">new</span> Solution().maximumMinimumPath(<span class="number">3</span>, connections));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        connections = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="keyword">new</span> Solution().maximumMinimumPath(<span class="number">4</span>, connections));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
